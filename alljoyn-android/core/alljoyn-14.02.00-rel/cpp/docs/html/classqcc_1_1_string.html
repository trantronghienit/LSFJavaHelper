<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>AllJoyn&trade; C++ API Reference Manual: qcc::String Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">AllJoyn&trade; C++ API Reference Manual
   &#160;<span id="projectnumber">Version 14.02.00</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>qcc</b>      </li>
      <li class="navelem"><a class="el" href="classqcc_1_1_string.html">String</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">qcc::String Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="qcc::String" -->
<p><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> is a heap-allocated array of bytes whose life-cycle is managed through reference counting.  
 <a href="classqcc_1_1_string.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_string_8h_source.html">String.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for qcc::String:</div>
<div class="dyncontent">
<div class="center"><img src="classqcc_1_1_string__coll__graph.png" border="0" usemap="#qcc_1_1_string_coll__map" alt="Collaboration graph"/></div>
<map name="qcc_1_1_string_coll__map" id="qcc_1_1_string_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classqcc_1_1_string-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>ManagedCtx</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7c3c5fe09e0661da9ec4f78af994acd"></a><!-- doxytag: member="qcc::String::iterator" ref="ab7c3c5fe09e0661da9ec4f78af994acd" args="" -->
typedef char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#ab7c3c5fe09e0661da9ec4f78af994acd">iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> iterator type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb2ea67988042b644e673966a5d2bd28"></a><!-- doxytag: member="qcc::String::const_iterator" ref="afb2ea67988042b644e673966a5d2bd28" args="" -->
typedef const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#afb2ea67988042b644e673966a5d2bd28">const_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">const <a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> iterator type <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6116dfaea9e788500723270ded16509f"></a><!-- doxytag: member="qcc::String::String" ref="a6116dfaea9e788500723270ded16509f" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a6116dfaea9e788500723270ded16509f">String</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty string. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a580c05403dd92c2e287f94861b860b63">String</a> (char c, size_t sizeHint=MinCapacity)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a single character string.  <a href="#a580c05403dd92c2e287f94861b860b63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a820c25c89a9b3490ef44130eceb573c1">String</a> (size_t n, char c, size_t sizeHint=MinCapacity)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> with n copies of char.  <a href="#a820c25c89a9b3490ef44130eceb573c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#adc677a2b7f5932c706986e8617a7fe3a">String</a> (const char *str, size_t strLen=0, size_t sizeHint=MinCapacity)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string from a const char*.  <a href="#adc677a2b7f5932c706986e8617a7fe3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a57b072e6bd30cba9fba81c5725948406">String</a> (const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;str)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Constructor.  <a href="#a57b072e6bd30cba9fba81c5725948406"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42301c4aab9613c12c0bba22848f5bc4"></a><!-- doxytag: member="qcc::String::~String" ref="a42301c4aab9613c12c0bba22848f5bc4" args="()" -->
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a42301c4aab9613c12c0bba22848f5bc4">~String</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6dd7dc779ef2913bfb242734df507143"></a><!-- doxytag: member="qcc::String::operator=" ref="a6dd7dc779ef2913bfb242734df507143" args="(const String &amp;assignFromMe)" -->
<a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a6dd7dc779ef2913bfb242734df507143">operator=</a> (const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;assignFromMe)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a3b7ad495f76f1b0cb809833e1d152089">assign</a> (const char *str, size_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a value to a string.  <a href="#a3b7ad495f76f1b0cb809833e1d152089"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#ab43b2104c1feedc71e9285b117307809">assign</a> (const char *str)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a nul-terminated string value to a string.  <a href="#ab43b2104c1feedc71e9285b117307809"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a8d4e71f1dea243c391b347e10f8cb7af">capacity</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current storage capacity for this string.  <a href="#a8d4e71f1dea243c391b347e10f8cb7af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html#ab7c3c5fe09e0661da9ec4f78af994acd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a87f0d6d7d0a841b17eec6727da7483a3">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the beginning of the string.  <a href="#a87f0d6d7d0a841b17eec6727da7483a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html#ab7c3c5fe09e0661da9ec4f78af994acd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a2e04f83189b3aebe7db0f21e34f08909">end</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the end of the string.  <a href="#a2e04f83189b3aebe7db0f21e34f08909"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html#afb2ea67988042b644e673966a5d2bd28">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a9d4d143d80714ed8eb8e59a970834a23">begin</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const_iterator to the beginning of the string.  <a href="#a9d4d143d80714ed8eb8e59a970834a23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html#afb2ea67988042b644e673966a5d2bd28">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#ade991b779b85e3b9045a9179f5a288eb">end</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the end of the string.  <a href="#ade991b779b85e3b9045a9179f5a288eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a1f665bd93b0177766ca3ed0848bdb130">clear</a> (size_t sizeHint=MinCapacity)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear contents of string.  <a href="#a1f665bd93b0177766ca3ed0848bdb130"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a2b41a2f204379ee9caf7330ff029af10">secure_clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unless you are working with passwords or cryptographic keys you should probably not be calling this function and should call <a class="el" href="classqcc_1_1_string.html#a1f665bd93b0177766ca3ed0848bdb130" title="Clear contents of string.">String::clear()</a> instead.  <a href="#a2b41a2f204379ee9caf7330ff029af10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a0cab536bfc0e09c4c2773333258ccb71">append</a> (const char *str, size_t len=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a string or substring to string.  <a href="#a0cab536bfc0e09c4c2773333258ccb71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a5a87c6d7cacc84868cd2ea9eee5a520d">append</a> (const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;str)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a string to another to string.  <a href="#a5a87c6d7cacc84868cd2ea9eee5a520d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a53370bcdd969d56e5a3516c1caa64b03">append</a> (const char c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a single character to string.  <a href="#a53370bcdd969d56e5a3516c1caa64b03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a6ab9bab8b38c12d09723d527286a6c55">erase</a> (size_t pos=0, size_t n=<a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a range of chars from string.  <a href="#a6ab9bab8b38c12d09723d527286a6c55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a51890a5d2721ae4092419dedf4037784">resize</a> (size_t n, char c= ' ')</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize string by appending chars or removing them to make string a specified size.  <a href="#a51890a5d2721ae4092419dedf4037784"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a5705db4cc148a35df1df9fb4b87d02ce">reserve</a> (size_t newCapacity)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set storage space for this string.  <a href="#a5705db4cc148a35df1df9fb4b87d02ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#ad95b9ee45b35220aac85d1b85472fdda">push_back</a> (char c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a single character to the end of the string.  <a href="#ad95b9ee45b35220aac85d1b85472fdda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a8ee70a274043aa5da4dc7df6e96a1726">operator+=</a> (const char c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a character.  <a href="#a8ee70a274043aa5da4dc7df6e96a1726"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#ac888806739ce715393de1b15d603afc7">operator+=</a> (const char *str)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Append to string.  <a href="#ac888806739ce715393de1b15d603afc7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a68040384a9db3ca326bc0c6b3537834a">operator+=</a> (const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;str)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Append to string.  <a href="#a68040384a9db3ca326bc0c6b3537834a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a82411f338a4a388dab075f661f36528e">insert</a> (size_t pos, const char *str, size_t len=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert characters into string at position.  <a href="#a82411f338a4a388dab075f661f36528e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a277e28d524c2cd6d65a30efba473bfdc">operator==</a> (const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;str) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if string is equal to this string.  <a href="#a277e28d524c2cd6d65a30efba473bfdc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a2cae4e1d52b991eb9fac9df9f1476eed">operator!=</a> (const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;str) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if string is not equal to this string.  <a href="#a2cae4e1d52b991eb9fac9df9f1476eed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a3947b461a68959cb7404a57951b55ec4">operator&lt;</a> (const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;str) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this string is less than other string.  <a href="#a3947b461a68959cb7404a57951b55ec4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a844bbf1cc6779e2253875652fe4a54d4">operator[]</a> (size_t pos)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the character at a given position.  <a href="#a844bbf1cc6779e2253875652fe4a54d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a2bf9acc27957a33bd69f8d3f81e6ca30">operator[]</a> (size_t pos) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a character at a given position.  <a href="#a2bf9acc27957a33bd69f8d3f81e6ca30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a14375835f7a2a1673852c04edf75f502">size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the string.  <a href="#a14375835f7a2a1673852c04edf75f502"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#af080b0ae3c1cd2309af753e1006f3925">length</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the string.  <a href="#af080b0ae3c1cd2309af753e1006f3925"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a13840ca89dab6e32df4660420cc5e2c8">c_str</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the null termination char* representation for this <a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a>.  <a href="#a13840ca89dab6e32df4660420cc5e2c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#ad2984600e187cd697cc5366d85517386">data</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the not-necessarily null termination char* representation for this <a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a>.  <a href="#ad2984600e187cd697cc5366d85517386"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a21d192442d2a6ad39be2c5e38937f803">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if string contains no chars.  <a href="#a21d192442d2a6ad39be2c5e38937f803"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a0efa86d9e36fcf4a70f441360dd5804b">find</a> (const char *str, size_t pos=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first occurrence of null terminated string within this string.  <a href="#a0efa86d9e36fcf4a70f441360dd5804b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a21e9278126aa3ccb4d46b8a003584773">find</a> (const <a class="el" href="classqcc_1_1_string.html">qcc::String</a> &amp;str, size_t pos=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first occurrence of string within this string.  <a href="#a21e9278126aa3ccb4d46b8a003584773"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a9dbd7131aaa754163454342726e4a52c">find_first_of</a> (const char c, size_t pos=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first occurrence of character within string.  <a href="#a9dbd7131aaa754163454342726e4a52c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a5f5a7efb1595db279bb65e8aa1323878">find_last_of</a> (const char c, size_t pos=<a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find last occurrence of character within string in range [0, pos).  <a href="#a5f5a7efb1595db279bb65e8aa1323878"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a89616fe36c356a0402f463ff658bfdff">find_first_of</a> (const char *inChars, size_t pos=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first occurence of any of a set of characters within string.  <a href="#a89616fe36c356a0402f463ff658bfdff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#ae40f15a054a17a153184970a0e962401">find_first_not_of</a> (const char *setChars, size_t pos=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first occurrence of a character NOT in a set of characters within string.  <a href="#ae40f15a054a17a153184970a0e962401"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#abcef5b6eff54978005ea564a126ffc43">find_last_not_of</a> (const char *setChars, size_t pos=<a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find last occurrence of a character NOT in a set of characters within string range [0, pos).  <a href="#abcef5b6eff54978005ea564a126ffc43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a7978196527560526efc5b3ff59a0b5a4">substr</a> (size_t pos=0, size_t n=<a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a substring of this string.  <a href="#a7978196527560526efc5b3ff59a0b5a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a03904cb64232fe2dc216446aeb600872">revsubstr</a> (size_t pos=0, size_t n=<a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a substring of this string with the order of the characters reversed.  <a href="#a03904cb64232fe2dc216446aeb600872"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#abc300e46efa86dbc49463926f072267c">compare</a> (const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare this string with other.  <a href="#abc300e46efa86dbc49463926f072267c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a6c25edda401ef83400608c7766ab7bae">compare</a> (size_t pos, size_t n, const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;other, size_t otherPos, size_t otherN) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a substring of this string with a substring of other.  <a href="#a6c25edda401ef83400608c7766ab7bae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a1764e14da6b793547034d357dfaf3812">compare</a> (size_t pos, size_t n, const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a substring of this string with other.  <a href="#a1764e14da6b793547034d357dfaf3812"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a425381919a032a2a69408e7036c0bd43">compare</a> (const char *str) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare this string with an array of chars.  <a href="#a425381919a032a2a69408e7036c0bd43"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5cd7c35050a5a8adb7415e7c18284f0"></a><!-- doxytag: member="qcc::String::npos" ref="ae5cd7c35050a5a8adb7415e7c18284f0" args="" -->
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a> = static_cast&lt;size_t&gt;(-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> index constant indicating "past the end". <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3886744d3ddbca66bdab32671309e825"></a><!-- doxytag: member="qcc::String::Empty" ref="a3886744d3ddbca66bdab32671309e825" args="" -->
static const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a3886744d3ddbca66bdab32671309e825">Empty</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the empty string. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> is a heap-allocated array of bytes whose life-cycle is managed through reference counting. </p>
<p>When all references to a <a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">qcc::String</a> instance go out of scope or are deleted, then the underlying heap-allocated storage is freed. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a580c05403dd92c2e287f94861b860b63"></a><!-- doxytag: member="qcc::String::String" ref="a580c05403dd92c2e287f94861b860b63" args="(char c, size_t sizeHint=MinCapacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html#a6116dfaea9e788500723270ded16509f">qcc::String::String</a> </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeHint</em> = <code>MinCapacity</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a single character string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Initial value for string </td></tr>
    <tr><td class="paramname">sizeHint</td><td>Optional size hint for initial allocation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a820c25c89a9b3490ef44130eceb573c1"></a><!-- doxytag: member="qcc::String::String" ref="a820c25c89a9b3490ef44130eceb573c1" args="(size_t n, char c, size_t sizeHint=MinCapacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html#a6116dfaea9e788500723270ded16509f">qcc::String::String</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeHint</em> = <code>MinCapacity</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a <a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> with n copies of char. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of chars in string. </td></tr>
    <tr><td class="paramname">c</td><td>Character used to fill string. </td></tr>
    <tr><td class="paramname">sizeHint</td><td>Optional size hint for initial allocation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc677a2b7f5932c706986e8617a7fe3a"></a><!-- doxytag: member="qcc::String::String" ref="adc677a2b7f5932c706986e8617a7fe3a" args="(const char *str, size_t strLen=0, size_t sizeHint=MinCapacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html#a6116dfaea9e788500723270ded16509f">qcc::String::String</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>strLen</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeHint</em> = <code>MinCapacity</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a string from a const char*. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>char* array to use as initial value for <a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a>. </td></tr>
    <tr><td class="paramname">strLen</td><td>Length of string or 0 if str is null terminated </td></tr>
    <tr><td class="paramname">sizeHint</td><td>Optional size hint used for initial malloc if larger than str length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57b072e6bd30cba9fba81c5725948406"></a><!-- doxytag: member="qcc::String::String" ref="a57b072e6bd30cba9fba81c5725948406" args="(const String &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html#a6116dfaea9e788500723270ded16509f">qcc::String::String</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy Constructor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0cab536bfc0e09c4c2773333258ccb71"></a><!-- doxytag: member="qcc::String::append" ref="a0cab536bfc0e09c4c2773333258ccb71" args="(const char *str, size_t len=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a>&amp; <a class="el" href="classqcc_1_1_string.html#a0cab536bfc0e09c4c2773333258ccb71">qcc::String::append</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append a string or substring to string. </p>
<p>This function will append all characters up to the specified length including embedded nuls.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Value to append to string. </td></tr>
    <tr><td class="paramname">len</td><td>Number of characters to append or 0 to insert up to first nul byte in str. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reference to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a87c6d7cacc84868cd2ea9eee5a520d"></a><!-- doxytag: member="qcc::String::append" ref="a5a87c6d7cacc84868cd2ea9eee5a520d" args="(const String &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a>&amp; <a class="el" href="classqcc_1_1_string.html#a0cab536bfc0e09c4c2773333258ccb71">qcc::String::append</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append a string to another to string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Value to append to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reference to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a53370bcdd969d56e5a3516c1caa64b03"></a><!-- doxytag: member="qcc::String::append" ref="a53370bcdd969d56e5a3516c1caa64b03" args="(const char c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a>&amp; <a class="el" href="classqcc_1_1_string.html#a0cab536bfc0e09c4c2773333258ccb71">qcc::String::append</a> </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append a single character to string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Character to append to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reference to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b7ad495f76f1b0cb809833e1d152089"></a><!-- doxytag: member="qcc::String::assign" ref="a3b7ad495f76f1b0cb809833e1d152089" args="(const char *str, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a>&amp; <a class="el" href="classqcc_1_1_string.html#a3b7ad495f76f1b0cb809833e1d152089">qcc::String::assign</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign a value to a string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Value to assign to string. </td></tr>
    <tr><td class="paramname">len</td><td>Number of characters to assign or 0 to insert up to first nul byte in str. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reference to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="ab43b2104c1feedc71e9285b117307809"></a><!-- doxytag: member="qcc::String::assign" ref="ab43b2104c1feedc71e9285b117307809" args="(const char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a>&amp; <a class="el" href="classqcc_1_1_string.html#a3b7ad495f76f1b0cb809833e1d152089">qcc::String::assign</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign a nul-terminated string value to a string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Value to assign to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reference to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a87f0d6d7d0a841b17eec6727da7483a3"></a><!-- doxytag: member="qcc::String::begin" ref="a87f0d6d7d0a841b17eec6727da7483a3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html#ab7c3c5fe09e0661da9ec4f78af994acd">iterator</a> <a class="el" href="classqcc_1_1_string.html#a87f0d6d7d0a841b17eec6727da7483a3">qcc::String::begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an iterator to the beginning of the string. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>iterator to start of string </dd></dl>

</div>
</div>
<a class="anchor" id="a9d4d143d80714ed8eb8e59a970834a23"></a><!-- doxytag: member="qcc::String::begin" ref="a9d4d143d80714ed8eb8e59a970834a23" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html#afb2ea67988042b644e673966a5d2bd28">const_iterator</a> <a class="el" href="classqcc_1_1_string.html#a87f0d6d7d0a841b17eec6727da7483a3">qcc::String::begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a const_iterator to the beginning of the string. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>iterator to start of string </dd></dl>

</div>
</div>
<a class="anchor" id="a13840ca89dab6e32df4660420cc5e2c8"></a><!-- doxytag: member="qcc::String::c_str" ref="a13840ca89dab6e32df4660420cc5e2c8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="classqcc_1_1_string.html#a13840ca89dab6e32df4660420cc5e2c8">qcc::String::c_str</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the null termination char* representation for this <a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Null terminated string. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d4e71f1dea243c391b347e10f8cb7af"></a><!-- doxytag: member="qcc::String::capacity" ref="a8d4e71f1dea243c391b347e10f8cb7af" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classqcc_1_1_string.html#a8d4e71f1dea243c391b347e10f8cb7af">qcc::String::capacity</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current storage capacity for this string. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Amount of storage allocated to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f665bd93b0177766ca3ed0848bdb130"></a><!-- doxytag: member="qcc::String::clear" ref="a1f665bd93b0177766ca3ed0848bdb130" args="(size_t sizeHint=MinCapacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classqcc_1_1_string.html#a1f665bd93b0177766ca3ed0848bdb130">qcc::String::clear</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeHint</em> = <code>MinCapacity</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear contents of string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeHint</td><td>Allocation size hint used if string must be reallocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc300e46efa86dbc49463926f072267c"></a><!-- doxytag: member="qcc::String::compare" ref="abc300e46efa86dbc49463926f072267c" args="(const String &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classqcc_1_1_string.html#abc300e46efa86dbc49463926f072267c">qcc::String::compare</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare this string with other. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>&lt;0 if this string is less than other, &gt;0 if this string is greater than other, 0 if equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c25edda401ef83400608c7766ab7bae"></a><!-- doxytag: member="qcc::String::compare" ref="a6c25edda401ef83400608c7766ab7bae" args="(size_t pos, size_t n, const String &amp;other, size_t otherPos, size_t otherN) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classqcc_1_1_string.html#abc300e46efa86dbc49463926f072267c">qcc::String::compare</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>otherPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>otherN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare a substring of this string with a substring of other. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Start position of this string. </td></tr>
    <tr><td class="paramname">n</td><td>Number of characters of this string to use for compare. </td></tr>
    <tr><td class="paramname">other</td><td><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> to compare with. </td></tr>
    <tr><td class="paramname">otherPos</td><td>Start position of other string. </td></tr>
    <tr><td class="paramname">otherN</td><td>Number of characters of other string to use for compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>&lt;0 if this string is less than other, &gt;0 if this string is greater than other, 0 if equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a1764e14da6b793547034d357dfaf3812"></a><!-- doxytag: member="qcc::String::compare" ref="a1764e14da6b793547034d357dfaf3812" args="(size_t pos, size_t n, const String &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classqcc_1_1_string.html#abc300e46efa86dbc49463926f072267c">qcc::String::compare</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare a substring of this string with other. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Start position of this string. </td></tr>
    <tr><td class="paramname">n</td><td>Number of characters of this string to use for compare. </td></tr>
    <tr><td class="paramname">other</td><td><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>&lt;0 if this string is less than other, &gt;0 if this string is greater than other, 0 if equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a425381919a032a2a69408e7036c0bd43"></a><!-- doxytag: member="qcc::String::compare" ref="a425381919a032a2a69408e7036c0bd43" args="(const char *str) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classqcc_1_1_string.html#abc300e46efa86dbc49463926f072267c">qcc::String::compare</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare this string with an array of chars. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Nul terminated array of chars to compare against this string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>&lt;0 if this string is less than str, &gt;0 if this string is greater than str, 0 if equal. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2984600e187cd697cc5366d85517386"></a><!-- doxytag: member="qcc::String::data" ref="ad2984600e187cd697cc5366d85517386" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="classqcc_1_1_string.html#ad2984600e187cd697cc5366d85517386">qcc::String::data</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the not-necessarily null termination char* representation for this <a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Null terminated string. </dd></dl>

</div>
</div>
<a class="anchor" id="a21d192442d2a6ad39be2c5e38937f803"></a><!-- doxytag: member="qcc::String::empty" ref="a21d192442d2a6ad39be2c5e38937f803" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classqcc_1_1_string.html#a21d192442d2a6ad39be2c5e38937f803">qcc::String::empty</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if string contains no chars. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true iff string is empty </dd></dl>

</div>
</div>
<a class="anchor" id="a2e04f83189b3aebe7db0f21e34f08909"></a><!-- doxytag: member="qcc::String::end" ref="a2e04f83189b3aebe7db0f21e34f08909" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html#ab7c3c5fe09e0661da9ec4f78af994acd">iterator</a> <a class="el" href="classqcc_1_1_string.html#a2e04f83189b3aebe7db0f21e34f08909">qcc::String::end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an iterator to the end of the string. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>iterator to end of string. </dd></dl>

</div>
</div>
<a class="anchor" id="ade991b779b85e3b9045a9179f5a288eb"></a><!-- doxytag: member="qcc::String::end" ref="ade991b779b85e3b9045a9179f5a288eb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html#afb2ea67988042b644e673966a5d2bd28">const_iterator</a> <a class="el" href="classqcc_1_1_string.html#a2e04f83189b3aebe7db0f21e34f08909">qcc::String::end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an iterator to the end of the string. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>iterator to end of string. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ab9bab8b38c12d09723d527286a6c55"></a><!-- doxytag: member="qcc::String::erase" ref="a6ab9bab8b38c12d09723d527286a6c55" args="(size_t pos=0, size_t n=npos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a>&amp; <a class="el" href="classqcc_1_1_string.html#a6ab9bab8b38c12d09723d527286a6c55">qcc::String::erase</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase a range of chars from string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Offset first char to erase. </td></tr>
    <tr><td class="paramname">n</td><td>Number of chars to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reference to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a0efa86d9e36fcf4a70f441360dd5804b"></a><!-- doxytag: member="qcc::String::find" ref="a0efa86d9e36fcf4a70f441360dd5804b" args="(const char *str, size_t pos=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classqcc_1_1_string.html#a0efa86d9e36fcf4a70f441360dd5804b">qcc::String::find</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find first occurrence of null terminated string within this string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> to find. </td></tr>
    <tr><td class="paramname">pos</td><td>Optional starting position (in this string) for search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Position of first occurrence of c within string or npos if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a21e9278126aa3ccb4d46b8a003584773"></a><!-- doxytag: member="qcc::String::find" ref="a21e9278126aa3ccb4d46b8a003584773" args="(const qcc::String &amp;str, size_t pos=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classqcc_1_1_string.html#a0efa86d9e36fcf4a70f441360dd5804b">qcc::String::find</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqcc_1_1_string.html">qcc::String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find first occurrence of string within this string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> to find within this string instance. </td></tr>
    <tr><td class="paramname">pos</td><td>Optional starting position (in this string) for search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Position of first occurrence of c within string or npos if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="ae40f15a054a17a153184970a0e962401"></a><!-- doxytag: member="qcc::String::find_first_not_of" ref="ae40f15a054a17a153184970a0e962401" args="(const char *setChars, size_t pos=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classqcc_1_1_string.html#ae40f15a054a17a153184970a0e962401">qcc::String::find_first_not_of</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>setChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find first occurrence of a character NOT in a set of characters within string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">setChars</td><td>Array of characters to (NOT) look for in this string. </td></tr>
    <tr><td class="paramname">pos</td><td>Optional starting position within this string for search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Position of first occurrence a character not in setChars or npos if none exists. </dd></dl>

</div>
</div>
<a class="anchor" id="a9dbd7131aaa754163454342726e4a52c"></a><!-- doxytag: member="qcc::String::find_first_of" ref="a9dbd7131aaa754163454342726e4a52c" args="(const char c, size_t pos=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classqcc_1_1_string.html#a9dbd7131aaa754163454342726e4a52c">qcc::String::find_first_of</a> </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find first occurrence of character within string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Charater to find. </td></tr>
    <tr><td class="paramname">pos</td><td>Optional starting position for search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Position of first occurrence of c within string or npos if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a89616fe36c356a0402f463ff658bfdff"></a><!-- doxytag: member="qcc::String::find_first_of" ref="a89616fe36c356a0402f463ff658bfdff" args="(const char *inChars, size_t pos=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classqcc_1_1_string.html#a9dbd7131aaa754163454342726e4a52c">qcc::String::find_first_of</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>inChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find first occurence of any of a set of characters within string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inChars</td><td>Array of characters to look for in this string. </td></tr>
    <tr><td class="paramname">pos</td><td>Optional starting position within this string for search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Position of first occurrence of one of inChars within string or npos if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="abcef5b6eff54978005ea564a126ffc43"></a><!-- doxytag: member="qcc::String::find_last_not_of" ref="abcef5b6eff54978005ea564a126ffc43" args="(const char *setChars, size_t pos=npos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classqcc_1_1_string.html#abcef5b6eff54978005ea564a126ffc43">qcc::String::find_last_not_of</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>setChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code><a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find last occurrence of a character NOT in a set of characters within string range [0, pos). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">setChars</td><td>Array of characters to (NOT) look for in this string. </td></tr>
    <tr><td class="paramname">pos</td><td>Position one past the end of the character of the substring that should be examined or npos for entire string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Position of first occurrence a character not in setChars or npos if none exists. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f5a7efb1595db279bb65e8aa1323878"></a><!-- doxytag: member="qcc::String::find_last_of" ref="a5f5a7efb1595db279bb65e8aa1323878" args="(const char c, size_t pos=npos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classqcc_1_1_string.html#a5f5a7efb1595db279bb65e8aa1323878">qcc::String::find_last_of</a> </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code><a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find last occurrence of character within string in range [0, pos). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Character to find. </td></tr>
    <tr><td class="paramname">pos</td><td>Optional starting position for search (one past end of substring to search). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Position of last occurrence of c within string or npos if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a82411f338a4a388dab075f661f36528e"></a><!-- doxytag: member="qcc::String::insert" ref="a82411f338a4a388dab075f661f36528e" args="(size_t pos, const char *str, size_t len=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a>&amp; <a class="el" href="classqcc_1_1_string.html#a82411f338a4a388dab075f661f36528e">qcc::String::insert</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert characters into string at position. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Insert position. </td></tr>
    <tr><td class="paramname">str</td><td>Character string to insert. </td></tr>
    <tr><td class="paramname">len</td><td>Optional number of chars to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reference to the string. </dd></dl>

</div>
</div>
<a class="anchor" id="af080b0ae3c1cd2309af753e1006f3925"></a><!-- doxytag: member="qcc::String::length" ref="af080b0ae3c1cd2309af753e1006f3925" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classqcc_1_1_string.html#af080b0ae3c1cd2309af753e1006f3925">qcc::String::length</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the length of the string. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>size of string. </dd></dl>

</div>
</div>
<a class="anchor" id="a2cae4e1d52b991eb9fac9df9f1476eed"></a><!-- doxytag: member="qcc::String::operator!=" ref="a2cae4e1d52b991eb9fac9df9f1476eed" args="(const String &amp;str) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qcc::String::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if string is not equal to this string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> to compare against this string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true iff other is not equal to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ee70a274043aa5da4dc7df6e96a1726"></a><!-- doxytag: member="qcc::String::operator+=" ref="a8ee70a274043aa5da4dc7df6e96a1726" args="(const char c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a>&amp; qcc::String::operator+= </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append a character. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Character to append to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reference to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="ac888806739ce715393de1b15d603afc7"></a><!-- doxytag: member="qcc::String::operator+=" ref="ac888806739ce715393de1b15d603afc7" args="(const char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a>&amp; qcc::String::operator+= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append to string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Value to append to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reference to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a68040384a9db3ca326bc0c6b3537834a"></a><!-- doxytag: member="qcc::String::operator+=" ref="a68040384a9db3ca326bc0c6b3537834a" args="(const String &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a>&amp; qcc::String::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append to string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Value to append to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reference to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a3947b461a68959cb7404a57951b55ec4"></a><!-- doxytag: member="qcc::String::operator&lt;" ref="a3947b461a68959cb7404a57951b55ec4" args="(const String &amp;str) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qcc::String::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if this string is less than other string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> to compare against this string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true iff this string is less than other string </dd></dl>

</div>
</div>
<a class="anchor" id="a277e28d524c2cd6d65a30efba473bfdc"></a><!-- doxytag: member="qcc::String::operator==" ref="a277e28d524c2cd6d65a30efba473bfdc" args="(const String &amp;str) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qcc::String::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if string is equal to this string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> to compare against this string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true iff other is equal to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a844bbf1cc6779e2253875652fe4a54d4"></a><!-- doxytag: member="qcc::String::operator[]" ref="a844bbf1cc6779e2253875652fe4a54d4" args="(size_t pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char&amp; qcc::String::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a reference to the character at a given position. </p>
<p>If pos &gt;= size, then 0 will be returned.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position offset into string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reference to character at pos. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bf9acc27957a33bd69f8d3f81e6ca30"></a><!-- doxytag: member="qcc::String::operator[]" ref="a2bf9acc27957a33bd69f8d3f81e6ca30" args="(size_t pos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char qcc::String::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a character at a given position. </p>
<p>This function performs no range checking so the caller is responsible for checking that pos is less than the size of the the string.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position offset into string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The character at pos. </dd></dl>

</div>
</div>
<a class="anchor" id="ad95b9ee45b35220aac85d1b85472fdda"></a><!-- doxytag: member="qcc::String::push_back" ref="ad95b9ee45b35220aac85d1b85472fdda" args="(char c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classqcc_1_1_string.html#ad95b9ee45b35220aac85d1b85472fdda">qcc::String::push_back</a> </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Push a single character to the end of the string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Char to push </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5705db4cc148a35df1df9fb4b87d02ce"></a><!-- doxytag: member="qcc::String::reserve" ref="a5705db4cc148a35df1df9fb4b87d02ce" args="(size_t newCapacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classqcc_1_1_string.html#a5705db4cc148a35df1df9fb4b87d02ce">qcc::String::reserve</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set storage space for this string. </p>
<p>The new capacity will be the larger of the current size and the specified new capacity.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">newCapacity</td><td>The desired capacity for this string. May be greater or less than current capacity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51890a5d2721ae4092419dedf4037784"></a><!-- doxytag: member="qcc::String::resize" ref="a51890a5d2721ae4092419dedf4037784" args="(size_t n, char c= ' ')" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classqcc_1_1_string.html#a51890a5d2721ae4092419dedf4037784">qcc::String::resize</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resize string by appending chars or removing them to make string a specified size. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>New size for string. </td></tr>
    <tr><td class="paramname">c</td><td>Character to append to string if string size increases. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03904cb64232fe2dc216446aeb600872"></a><!-- doxytag: member="qcc::String::revsubstr" ref="a03904cb64232fe2dc216446aeb600872" args="(size_t pos=0, size_t n=npos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a> <a class="el" href="classqcc_1_1_string.html#a03904cb64232fe2dc216446aeb600872">qcc::String::revsubstr</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a substring of this string with the order of the characters reversed. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Starting position of substring. </td></tr>
    <tr><td class="paramname">n</td><td>Number of bytes in substring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The reversed substring of this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b41a2f204379ee9caf7330ff029af10"></a><!-- doxytag: member="qcc::String::secure_clear" ref="a2b41a2f204379ee9caf7330ff029af10" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classqcc_1_1_string.html#a2b41a2f204379ee9caf7330ff029af10">qcc::String::secure_clear</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unless you are working with passwords or cryptographic keys you should probably not be calling this function and should call <a class="el" href="classqcc_1_1_string.html#a1f665bd93b0177766ca3ed0848bdb130" title="Clear contents of string.">String::clear()</a> instead. </p>
<p>Clears the context of a string by zeroing out the internal string and setting the length to zero. This function is intended for use by security related functions for zeroing out sensitive information such as passwords and cryptographic keys immediately after they have been used to minimize the time that sensitive information is in memory. This function has the side effect of clearing all copies of this string that may have result from string assignment operations. To aid in verifying the behavior is as expected this function returns a count of the number of strings that reference the same internal string data. If this value is not zero then there are other copies of the string that were also cleared. If this happens it was most likely due to a coding error.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of other string instances that were cleared as a side-effect of clearing this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a14375835f7a2a1673852c04edf75f502"></a><!-- doxytag: member="qcc::String::size" ref="a14375835f7a2a1673852c04edf75f502" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classqcc_1_1_string.html#a14375835f7a2a1673852c04edf75f502">qcc::String::size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the size of the string. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>size of string. </dd></dl>

</div>
</div>
<a class="anchor" id="a7978196527560526efc5b3ff59a0b5a4"></a><!-- doxytag: member="qcc::String::substr" ref="a7978196527560526efc5b3ff59a0b5a4" args="(size_t pos=0, size_t n=npos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a> <a class="el" href="classqcc_1_1_string.html#a7978196527560526efc5b3ff59a0b5a4">qcc::String::substr</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a substring of this string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Starting position of substring. </td></tr>
    <tr><td class="paramname">n</td><td>Number of bytes in substring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Substring of this string. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_string_8h_source.html">String.h</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<!--
Copyright (c) 2009-2014, AllSeen Alliance. All rights reserved.

   Permission to use, copy, modify, and/or distribute this software for any
   purpose with or without fee is hereby granted, provided that the above
   copyright notice and this permission notice appear in all copies.

   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
   WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
   ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

-->
<!--oinaf1-->
<hr>
<small>

AllJoyn&trade; C++ API Reference Manual Version 14.02.00 (Fri Feb 28 2014 15:05:30)<br/>
Copyright &copy; 2009-2014 AllSeen Alliance.<br/>

<p>AllJoyn is a trademark of Qualcomm Innovation Center, Inc. AllJoyn is
used here with permission to identify unmodified materials originating
in the AllJoyn project.<br/>
The AllJoyn open source project is hosted by the AllSeen Alliance.</p>

<b>THIS DOCUMENT AND ALL INFORMATION CONTAIN HEREIN ARE PROVIDED ON AN "AS-IS" BASIS WITHOUT WARRANTY OF ANY KIND</b>.<br/>
<b>MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION</b><br/>

</small>
</body>
</html>
<!--oinaf2-->
